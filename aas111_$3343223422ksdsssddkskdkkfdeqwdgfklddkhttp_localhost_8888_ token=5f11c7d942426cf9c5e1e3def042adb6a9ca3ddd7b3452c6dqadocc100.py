# -*- coding: utf-8 -*-
"""AAS111#@#@$3343223422KSDSSSDDKSKDKKFDEqwdGFKLDDKhttp://localhost:8888/?token=5f11c7d942426cf9c5e1e3def042adb6a9ca3ddd7b3452c6Dqadocc100.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XUCniHN1lXp9CZqvDaYHujWZr6PG684R
"""

#!git clone https://github.com/Lu-Yi-Hsun/iqoptionapi.git

# Commented out IPython magic to ensure Python compatibility.
# %ls

#!python3 setup.py install

api = conection()http://localhost:8888/?token=13a87d06cf3605df1b9d2e8e85d15d391c27547152fbef7f

import time
import json
import numpy as np
import pandas as pd
import datetime
import pytz
#from xgboost import XGBClassifier
from sklearn.metrics import accuracy_score

def conection():
    from iqoptionapi.stable_api import IQ_Option
    session_conection = IQ_Option("mtavaressv@gmail.com", "asdqwezxc123")

    header={"User-Agent":r"Mozilla/5.0 (X11; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0"}
    cookie={"session_conection":"GOOD"}

    session_conection.set_session(header,cookie)

    try:
        session_conection.connect()
        print("Conectado")
        return session_conection
    except:
        print("Erro ao Conectar")
        return '202'

def get_candles_t(api, qt_candles, candle_period, ativo):
    try:

        goal = ativo
        data = api.get_candles(goal, candle_period, qt_candles, time.time())
        candles = pd.DataFrame(data)
        return candles
    except Exception as e:
        print(e)
        return '202'

#Inicialização
api = conection()
nomes = api.update_ACTIVES_OPCODE()
print(nomes)

import pandas as pd
import mplfinance as mpf
import matplotlib.pyplot as plt
import talib
import time
from datetime import datetime
import pytz
import os
import joblib

import matplotlib.pyplot as plt
from sklearn.datasets import make_blobs
from sklearn.cluster import KMeans
from sklearn.decomposition import PCA
import numpy as np
import pandas as pd
import joblib

from sklearn.cluster import MiniBatchKMeans
from sklearn.preprocessing import StandardScaler


api = conection()

ativo = input("Digite o ativo: ")

def detectar_padroes(df):
    padroes = {"Alta": [], "Baixa": []}
    for padrao in talib.get_function_groups()["Pattern Recognition"]:
        func = getattr(talib, padrao)
        resultado = func(df["Open"], df["High"], df["Low"], df["Close"])
        df[padrao] = resultado
        if resultado.max() > 0:
            padroes["Alta"].append(padrao)
        if resultado.min() < 0:
            padroes["Baixa"].append(padrao)
    return padroes

B = int(input("Digite qt_candles: "))
C = int(input("Digite candle_period: "))
period = int(input("Digite o periodo: "))



historico_resultados = []
historico_tempos = []
saldo_acumulado = 0

csv_file_name = "dados_treino.csv"
jolib_file_name = 'modelo_kmeans.pkl'

if not os.path.isfile(csv_file_name):
    X = pd.DataFrame()
    print("Dados Iniciados")
else:
    X = pd.read_csv(csv_file_name)
    print("Dados Carregados")

if os.path.isfile(jolib_file_name):
    kmeans = joblib.load(jolib_file_name)
    print("Modelo Carregado")
else:
    kmeans = MiniBatchKMeans(n_clusters=2, batch_size=int((90/100)*len(X)), random_state=42)
    print("Modelo Inicializado")

scaler = StandardScaler()
interaction = 1

while True:

    if api.get_remaning(1) - 30 == 60:

        df = get_candles_t(api, qt_candles=B, candle_period=C, ativo=ativo)
        df["to"] = pd.to_datetime(df["to"], unit='s')
        df.set_index("to", inplace=True)
        df.rename(columns={"open": "Open", "close": "Close", "min": "Low", "max": "High"}, inplace=True)

        df["resistencia"] = (df["High"] > df["High"].shift(3)) & (df["High"] > df["High"].shift(-3))
        df["suporte"] = (df["Low"] < df["Low"].shift(3)) & (df["Low"] < df["Low"].shift(-3))

        picos = df[df["resistencia"]]
        fundos = df[df["suporte"]]
        padroes = detectar_padroes(df)

        fig, ax = plt.subplots(figsize=(35, 12))
        mpf.plot(df, type="candle", style="charles", ax=ax, show_nontrading=True)

        for preco in picos["High"]:
            ax.hlines(y=preco, xmin=df.index[0], xmax=df.index[-1], colors="blue", linestyles="dashed", linewidth=1)
        for preco in fundos["Low"]:
            ax.hlines(y=preco, xmin=df.index[0], xmax=df.index[-1], colors="red", linestyles="dashed", linewidth=1)

        for padrao in padroes["Alta"]:
            reversao_alta = df[df[padrao] > 0]
            ax.scatter(reversao_alta.index, reversao_alta["High"], color="red", marker="^", s=190)
        for padrao in padroes["Baixa"]:
            reversao_baixa = df[df[padrao] < 0]
            ax.scatter(reversao_baixa.index, reversao_baixa["Low"], color="purple", marker="v", s=190)

        ax.scatter(df.index, df["Open"], color="green", marker="o", s=50)
        ax.scatter(df.index, df["Close"], color="red", marker="o", s=50)
        ax.set_title("Pontos de Suporte, Resistência e Padrões de Reversão")
        ax.set_ylabel("Preço")
        plt.show()

        tempo_operacao = datetime.now(pytz.timezone('America/Sao_Paulo'))
        print(tempo_operacao)

        if interaction == 0:
            X = df.loc[:, 'CDL2CROWS':]

        last = df.tail(1).loc[:, 'CDL2CROWS':]
        last_scaled = scaler.fit_transform(last)
        print('QTX', len(X))

        if interaction > 0 and interaction % 500 == 0 or interaction == 1 :
            print("Atualizando Modelo")
            kmeans.fit(X)
            joblib.dump(kmeans, jolib_file_name)

        prediction = kmeans.predict(last_scaled)
        print(prediction)

        if prediction == [0]:
            print("Compra")
            move = 'call'
        elif prediction == [1]:
            print("Venda")
            move = 'put'
        else:
            print("SEM AÇÃO")
            continue

        #labels = kmeans.labels_
        #centroids = kmeans.cluster_centers_
        #print(labels)
        #print(centroids)

        if True:
            print('check')
            check, id = api.buy_digital_spot(ativo, 1, move, period)
            print(check, id)

            if id != "error":
                while True:
                    check, win = api.check_win_digital_v2(id)
                    if check:
                        break

                saldo_acumulado += win
                if win > 0:
                    print("You win!", f"{win}$")
                else:
                    print("You loss!", f"{win}$")

            else:
                print("please try again")

            historico_resultados.append(saldo_acumulado)
            historico_tempos.append(tempo_operacao)

            plt.figure(figsize=(10, 4))
            plt.plot(historico_tempos, historico_resultados, marker='o', linestyle='-', color='green' if saldo_acumulado >= 0 else 'red')
            plt.title("Histórico de Resultados Acumulados")
            plt.xlabel("Tempo")
            plt.ylabel("Score ($)")
            plt.grid(True)
            plt.tight_layout()
            plt.show()

            if interaction == 0:
                X_scaled = scaler.fit_transform(X)
                # Convert the NumPy array to a Pandas DataFrame before calling to_csv
                X_scaled_df = pd.DataFrame(X_scaled, columns=X.columns)
                X_scaled_df.to_csv(csv_file_name, index=False)
                X = X_scaled_df # Assign the DataFrame to X
                interaction += 1
            else:
                last_scaled = pd.DataFrame(last_scaled, columns=last.columns)
                X = pd.concat([X, last_scaled], ignore_index=True)
                X.to_csv(csv_file_name, index=False)
                interaction += 1


            # Prever rótulos
            labels = kmeans.predict(X)
            centroids = kmeans.cluster_centers_

            # Aplicar PCA nos dados e também nos centróides
            pca = PCA(n_components=20)
            X_pca = pca.fit_transform(X)
            centroids_pca = pca.transform(centroids)

            # Plotar
            plt.figure(figsize=(18, 6))
            plt.scatter(X_pca[:, 0], X_pca[:, 1], c=labels, cmap='viridis', alpha=0.9)
            # Destaque no último ponto
            plt.scatter(X_pca[-1, 0], X_pca[-1, 1], color='blue', s=200, edgecolors='pink', linewidths=10.5, label='Último ponto')
            plt.scatter(centroids_pca[:, 0], centroids_pca[:, 1], marker='X', s=200, linewidths=0.1, color='r')


            plt.title("Clusters em espaço reduzido com PCA")
            plt.xlabel("PCA 1")
            plt.ylabel("PCA 2")
            plt.grid(True)
            plt.legend()
            plt.show()

import matplotlib.pyplot as plt
from sklearn.datasets import make_blobs
from sklearn.cluster import KMeans
from sklearn.decomposition import PCA
import numpy as np
import pandas as pd
import joblib

csv_file_name = "dados_treino.csv"
jolib_file_name = 'modelo_kmeans.pkl'

# Ler os dados
X = pd.read_csv(csv_file_name).values  # Já como NumPy array

n_features = X.shape[1]

centroid_init = np.random.uniform(low=-1.0, high=1.0, size=(2, 61))

# Carregar modelo e ajustar com novos dados
kmeans = kmeans = MiniBatchKMeans(n_clusters=2, init=centroid_init, n_init=1, random_state=42) #joblib.load(jolib_file_name)
kmeans.fit(X)

# Prever rótulos
labels = kmeans.predict(X)
centroids = kmeans.cluster_centers_

# Aplicar PCA nos dados e também nos centróides
pca = PCA(n_components=20)
X_pca = pca.fit_transform(X)
centroids_pca = pca.transform(centroids)

# Plotar
plt.figure(figsize=(18, 6))
plt.scatter(X_pca[:, 0], X_pca[:, 1], c=labels, cmap='viridis', alpha=0.5)
# Destaque no último ponto
plt.scatter(X_pca[-1, 0], X_pca[-1, 1], color='blue', s=200, edgecolors='pink', linewidths=8.5, label='Último ponto')
plt.scatter(centroids_pca[:, 0], centroids_pca[:, 1], marker='X', s=200, linewidths=0.1, color='r')


plt.title("Clusters em espaço reduzido com PCA")
plt.xlabel("PCA 1")
plt.ylabel("PCA 2")
plt.grid(True)
plt.legend()
plt.show()

# Salvar treinamento
joblib.dump(kmeans, jolib_file_name)

centroid_init



"""# Coigos extras"""



12# Codigo sem TA-lib

import pandas as pd
import mplfinance as mpf
import matplotlib.pyplot as plt
import time

ativo = "EURUSD-OTC"

while True:

    dados = get_candles_t(api, qt_candles=120, candle_period=5, ativo=ativo) # h em min / mili in seg

    # Simulação dos dados com base na estrutura fornecida
    df = dados

    # Converter timestamp para índice datetime
    df["to"] = pd.to_datetime(df["to"], unit='s')
    df.set_index("to", inplace=True)

    # Renomear colunas para compatibilidade com mplfinance
    df.rename(columns={"open": "Open", "close": "Close", "min": "Low", "max": "High"}, inplace=True)

    # Identificar resistências (picos) e suportes (fundos)
    df["resistencia"] = (df["High"] > df["High"].shift(12)) & (df["High"] > df["High"].shift(-12))
    df["suporte"] = (df["Low"] < df["Low"].shift(12)) & (df["Low"] < df["Low"].shift(-12))

    # Filtrar pontos de reversão
    picos = df[df["resistencia"]]
    fundos = df[df["suporte"]]

    # Criar gráfico de candles
    fig, ax = plt.subplots(figsize=(35, 8))

    mpf.plot(df, type="candle", style="charles", ax=ax, show_nontrading=True)

    # Adicionar linhas horizontais para suporte e resistência
    for preco in picos["High"]:
        ax.hlines(y=preco, xmin=df.index[0], xmax=df.index[-1], colors="blue", linestyles="dashed", linewidth=1)

    for preco in fundos["Low"]:
        ax.hlines(y=preco, xmin=df.index[0], xmax=df.index[-1], colors="red", linestyles="dashed", linewidth=1)

    # Configuração do gráfico
    ax.set_title("Pontos de Suporte e Resistência")
    ax.set_ylabel("Preço")
    plt.show()

    #aplicar time sleep deacordo com as configuraçoes de get_candles
    time.sleep(3)

# Algoritmo com bullets de abertura e fechamento


import pandas as pd
import mplfinance as mpf
import matplotlib.pyplot as plt
import talib
import time

ativo = "EURUSD-OTC"

# Lista de todos os padrões de reversão do TA-Lib
def detectar_padroes(df):
    padroes = {
        "Alta": [],
        "Baixa": []
    }

    for padrao in talib.get_function_groups()["Pattern Recognition"]:
        func = getattr(talib, padrao)
        resultado = func(df["Open"], df["High"], df["Low"], df["Close"])

        # Padrões retornam valores positivos para alta e negativos para baixa
        df[padrao] = resultado

        if resultado.max() > 0:
            padroes["Alta"].append(padrao)
        if resultado.min() < 0:
            padroes["Baixa"].append(padrao)

    return padroes

open_ant = 0

B = int(input("Digite qt_candles: "))
C = int(input("Digite candle_period: "))

for i in range(0, 9**99):

    dados = get_candles_t(api, qt_candles=B, candle_period=C, ativo=ativo)  # h em min / mili in seg

    # Simulação dos dados com base na estrutura fornecida
    df = dados

    # Converter timestamp para índice datetime
    df["to"] = pd.to_datetime(df["to"], unit='s')
    df.set_index("to", inplace=True)

    # Renomear colunas para compatibilidade com mplfinance
    df.rename(columns={"open": "Open", "close": "Close", "min": "Low", "max": "High"}, inplace=True)

    # Identificar resistências (picos) e suportes (fundos)
    df["resistencia"] = (df["High"] > df["High"].shift(12)) & (df["High"] > df["High"].shift(-12))
    df["suporte"] = (df["Low"] < df["Low"].shift(12)) & (df["Low"] < df["Low"].shift(-12))

    # Filtrar pontos de reversão
    picos = df[df["resistencia"]]
    fundos = df[df["suporte"]]

    # Detectar padrões de reversão
    padroes = detectar_padroes(df)

    open_new = df.tail(1)['from']
    if i != 0 and open_ant.to_string(index=False) != open_new.to_string(index=False):

        # Criar gráfico de candles
        fig, ax = plt.subplots(figsize=(35, 18))

        mpf.plot(df, type="candle", style="charles", ax=ax, show_nontrading=True)

        # Adicionar linhas horizontais para suporte e resistência
        for preco in picos["High"]:
            ax.hlines(y=preco, xmin=df.index[0], xmax=df.index[-1], colors="blue", linestyles="dashed", linewidth=1)

        for preco in fundos["Low"]:
            ax.hlines(y=preco, xmin=df.index[0], xmax=df.index[-1], colors="red", linestyles="dashed", linewidth=1)

        # Adicionar triângulos para padrões de reversão
        for padrao in padroes["Alta"]:
            reversao_alta = df[df[padrao] > 90]
            ax.scatter(reversao_alta.index, reversao_alta["High"], color="yellow", marker="^", s=190, label="Reversão de Alta")

        for padrao in padroes["Baixa"]:
            reversao_baixa = df[df[padrao] < -90]
            ax.scatter(reversao_baixa.index, reversao_baixa["Low"], color="purple", marker="v", s=190, label="Reversão de Baixa")

        # Adicionar pontos para abertura e fechamento de cada vela
        ax.scatter(df.index, df["Open"], color="green", marker="o", s=50, label="Abertura")
        ax.scatter(df.index, df["Close"], color="red", marker="o", s=50, label="Fechamento")

        # Configuração do gráfico
        ax.set_title("Pontos de Suporte, Resistência e Padrões de Reversão")
        ax.set_ylabel("Preço")
        ax.legend()
        plt.show()

        # Printar tempo atual fuso horário brasileiro
        print(datetime.datetime.now(pytz.timezone('America/Sao_Paulo')))

        # Aplicar time.sleep de acordo com as configurações de get_candles
        time.sleep(0.1)

    open_ant = df.tail(1)['from']

#Atualização de ativos abertos no momento (Necesario para caso de erro em aativo)
api.update_ACTIVES_OPCODE()

# Obter lista de ativos abertos na Digital
ativos_abertos = api.get_all_open_time()

# Filtrar apenas moedas disponíveis na Digital Aberta
vativos = [ativo for ativo, status in ativos_abertos["digital"].items() if status["open"]]
if True:
    if True:
        for ativo in vativos:
            ACTIVES=ativo
            duration=1
            amount=1
            action="put"
            check, id = api.buy_digital_spot(ACTIVES,amount,action,duration)
            print(check,id, ativo)
            if id !="error":
                print("buy")
                while True:

                    check,win=api.check_win_digital_v2(id)
                    if check==True:
                        break
                if win<0:
                    print("You loss! "+str(win)+"$")
                else:
                    print("You win! "+str(win)+"$")
            else:
                print("please try again")

#


import pandas as pd
import mplfinance as mpf
import matplotlib.pyplot as plt
import talib
import time
from datetime import datetime, timedelta
import pytz


api.update_ACTIVES_OPCODE()

ativo = input("Digite o ativo: ")

# Lista
def detectar_padroes(df):
    padroes = {
        "Alta": [],
        "Baixa": []
    }

    for padrao in talib.get_function_groups()["Pattern Recognition"]:
        func = getattr(talib, padrao)
        resultado = func(df["Open"], df["High"], df["Low"], df["Close"])

        # Padrões retornam valores positivos para alta e negativos para baixa
        df[padrao] = resultado

        if resultado.max() > 0:
            padroes["Alta"].append(padrao)
        if resultado.min() < 0:
            padroes["Baixa"].append(padrao)

    return padroes

B = int(input("Digite qt_candles: "))
C = int(input("Digite candle_period: "))
period = int(input("Digite o periodo: "))

while True:
    remaning_time=api.get_remaning(1)-30
    if remaning_time == 60:

        dados = get_candles_t(api, qt_candles=B, candle_period=C, ativo=ativo)  # h em min / mili in seg

        # Simulação dos dados com base na estrutura fornecida
        df = dados

        # Converter timestamp para índice datetime
        df["to"] = pd.to_datetime(df["to"], unit='s')
        df.set_index("to", inplace=True)

        # Renomear colunas para compatibilidade com mplfinance
        df.rename(columns={"open": "Open", "close": "Close", "min": "Low", "max": "High"}, inplace=True)

        # Identificar resistências (picos) e suportes (fundos)
        df["resistencia"] = (df["High"] > df["High"].shift(3)) & (df["High"] > df["High"].shift(-3))
        df["suporte"] = (df["Low"] < df["Low"].shift(3)) & (df["Low"] < df["Low"].shift(-3))

        # Filtrar pontos de reversão
        picos = df[df["resistencia"]]
        fundos = df[df["suporte"]]

        # Detectar padrões de reversão
        padroes = detectar_padroes(df)

        open_new = df.tail(1)['from']

        # Criar gráfico de candles
        fig, ax = plt.subplots(figsize=(35, 12))

        mpf.plot(df, type="candle", style="charles", ax=ax, show_nontrading=True)

        # Adicionar linhas horizontais para suporte e resistência
        for preco in picos["High"]:
            ax.hlines(y=preco, xmin=df.index[0], xmax=df.index[-1], colors="blue", linestyles="dashed", linewidth=1)

        for preco in fundos["Low"]:
            ax.hlines(y=preco, xmin=df.index[0], xmax=df.index[-1], colors="red", linestyles="dashed", linewidth=1)

        # Adicionar triângulos para padrões de reversão
        for padrao in padroes["Alta"]:
            reversao_alta = df[df[padrao] > 0]
            ax.scatter(reversao_alta.index, reversao_alta["High"], color="red", marker="v", s=190, label="Reversão de Alta")

        for padrao in padroes["Baixa"]:
            reversao_baixa = df[df[padrao] < 0]
            ax.scatter(reversao_baixa.index, reversao_baixa["Low"], color="purple", marker="^", s=190, label="Reversão de Baixa")

        # Adicionar pontos para abertura e fechamento de cada vela
        ax.scatter(df.index, df["Open"], color="green", marker="o", s=50, label="Abertura")
        ax.scatter(df.index, df["Close"], color="red", marker="o", s=50, label="Fechamento")

        # Configuração do gráfico
        ax.set_title("Pontos de Suporte, Resistência e Padrões de Reversão")
        ax.set_ylabel("Preço")
        #ax.legend()
        plt.show()
        #printar hora atual
        print(datetime.now(pytz.timezone('America/Sao_Paulo')))

        A = pd.Series(df.tail(2).head(1).loc[:, 'CDL2CROWS':].to_numpy().flatten()).value_counts()
        print(A)
        #.head(1)
        dic = A.to_dict()
        if 0 in dic.keys() and len(dic.keys()) > 1:
            dic.pop(0)
            h = list(dic.keys())[list(dic.keys()).index(max(dic.keys(), key=abs))]
            p = dic[h]

        else:
            h = 0
            p = 99999

        move = 0
        # se count 100 in A > 1 e count -100 in A == False entao printar compra
        if  h > 0 and p == max(list(dic.values())):
            print("Venda")
            move = 'put'
        elif h < 0 and p == max(list(dic.values())):
            print("Compra")
            move = 'call'
        else:
            print("SEM AÇÃO")
            # pular restante do codigo
            continue

        if move != 0:

            ACTIVES=ativo
            duration=period
            amount=1
            action=move#put
            check, id = api.buy_digital_spot(ACTIVES,amount,action,duration)
            print(check,id)
            if id !="error":
                while True:
                    check,win=api.check_win_digital_v2(id)
                    if check==True:
                        break
                if win<0:
                    print("You loss! "+str(win)+"$")
                else:
                    print("You win! "+str(win)+"$")
            else:
                print("please try again")